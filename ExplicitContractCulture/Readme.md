Explicit Architecture - right way to track contract dependencies
What our services can do very depends on their dependencies. 
Dependencies may be different, have different life cycle and value. 
However there is one common methodological aspect about dependencies: dependencies may be declare Explicitly or may occur Implicitly. 
I will to explain why from my expertise Explicit dependency is always better and Implicit dependency looks like quick solution but cause problems. 
Importance of "Explicit" word in architecture is on different levels. "Explicit" is related to "Dependencies". I just will show few aspects when Explicit helps us to track dependencies.
1. Strongly typed languages allows us to declare objects with contract structure. For example TypeScript is better than JavaScript. We may know what to expect from an object.
2. OOP Incapsulation is about sharing only explicitly specified contracts: allowing to access only state that we explicitly allow to access and call only methods that we explicitly allow to call.
3. One of core Service Oriented Architecture is "Contract First". We explicitly say what we publish as contract and nothing else. Contract is something that has life cycle and has consequence.
4. Database table schema is Explicit contract. NoSQL doesn't mean of no schema; it must means that NoSQL engine doesn't enforce schema but Explicit schema must be on logic level. You may see Martin Fowler NoSQL book. Too many stories about teams who were putting data into NoSQL without any responsibility on the schema. 
5. Functional languages make declarations immutable by default because if you want mutability you have to ask about it explicitly. It allows to avoid situation that someone messed up structures from parallel thread.
6. Dependency Injection is about Explicit tracking of dependencies. Dependencies in compositions graph should formulate direct graph without loops where is no any kind of cross-coupling or transitional coupling.
7. There are contract refactoring practices e.g. Database Refactoring Patterns and they are complex processes when contract is unified  and depricate

There may be much more samples but let's talk about cases when implicit dependencies occur:
1. Separation of concerns: Domain objects should be separated from IO contracts (DataAccessObjects or DataTransfer) Objects. When we don't do such a simple excessive then any change to domain objects breaks IO contracts where. It doesn't become important until small pilot starts growing or changing. It is completely healthy practice to be able to change everything that is no marked as contract. If it compiles then it works. If property rename in Domain object cause out because it was unexpectely sent to the Kusto and someone developed logic based on that problerty name then all project philosopy becomes "don't touch if it works" but reality is that "don't touch this card because it is on keeps this card house". 
2. I don't like automappers. Modern languages especially as C#9, F# support record types that allow to make mapping in very short manner. Using automappers is like putting peace of vanila JavaScript into stronly typed .NET. When we map to IO contract we make it explicitly because in this moment we declare contract between our process and out-of-process world.
3. Violation of SOA princyples. There is no microservice architecture without SOA princyples. Distributed Monolith antipattern it is what happen when people go to micro-services with SOA principles ignorance. It is incredibly common issue in many companies. And capitally this story becomes drama when someone another comes to the project and understands that it is distributed monoligh and have to rejoin/resplit services first before being able to meet new grow.

There is classical sorry in project management books about V2 crisis that happens when V1 was released successfully and customers want V2 be released with even faster tempo. That's why architects invented SOLID and SOA principles. SOLID allows to do reusability on OOP level. SOLID allows to do not drop classes on V2. SOA allows to do reusability on service level. SOA allows to design services that will be sold in few years in the future. Both principles are mirrored and have common goal to design.
Please, make contracts explicit, spend a minute to map and save days in contracts upgrade because contracts upgrade. Making implicit contracts is irresponsible behavior in relation to those who will support that contracts because they will have to recursively scan who and how may use anything as a contract because everything that went out of the process may become an implicit contract and become implicit contract for many subsystems. Implicit contracts cause chaos with many "Butterfly effects". 

Having "Explicit Contracts Culture" (personal, team and corporate) is very important. Absence of corporate "Explicit Contracts Culture" it is end of the business. Microsoft has very strong culture of contracts because it is ground of relationships with customers. I know that COSINE team is steal making some patching to Windows XP customers and that is big chellenge to evolve new and respond for old. I think that not all teams articulate contracts culture. On individuals level there is good point that to prototype fast dev may skip making explicit contracts but I wish before releasing code must have all classes that are contracts be marked in some way that this class is contract for following purposes. If class is contract for both DocumentDb and Kosmos there must be note about this. Otherwise when I see the class I sould see that it has two responsibilities and if I will want to change only Kusto contract I will split one data model in two and modify only one (e.g. Kusto related). Working in projects where class has thousand of ussages where it is necessary to research all of them before make decision about its implicit contract ussages is very long and hardly trackable process.

That's why personally I always crate separate data models for each individual persistence sources. I needed to persist one entity to Redis and Kosmos, I create common canonical model, Redis Data model and Kusto Data model, remapped, serialized them individually. Now I may evolve my canonical common model as I want as only it is compilable but Redis and CosmosDb models are contracts.
