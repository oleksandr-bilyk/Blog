# Azure AppService HttpClientFactory - use cached but fresh http message handlers.

There is one trend in technical industry: recommendations are intended to be elevated to requirements. Times when developers read documentation from cover to cover are long gone and we have to react for issues that a platform enforces. 
Migration from Service Fabric clusters running on Virtual Machine Scale Set to Azure AppService enforces more strict requirements to .NET outbound connection practices. In 2015 first generation of AppService was running on dedicated VMs.
Modern Azure AppService (2020+) (WebSites and AzureFunction) work in environment has 128 SNAT ports limit. MSDN articles sometimes are controversial. It has taken to read many of them, practice codding, read source code and debug DefaultHttpClientFactory internals to figure out universal codding practice:
1. Use cached but fresh http message handlers
   1. Do not create HttpClient using its constructor because it creates many HttpMessageHandlers and reaches SNAT ports limit.
   2. Don't use HttpClient singleton because it makeslinked HttpMessageHandlers not fresh and may cause DNS problems. 
2. Use [AddHttpClient](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) that registers IHttpClientFactory and IHttpMessageHandlerFactory singletons dependency injection that are implemented in [DefaultHttpClientFactory](https://github.com/aspnet/HttpClientFactory/blob/master/src/Microsoft.Extensions.Http/DefaultHttpClientFactory.cs). You may inject these factories into your own services with any [DI lifetimes](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes) (transient or singleton). DefaultHttpClientFactory internally contains dictionary of named HttpMessageHandler's instances that are expired in 2 minutes after creation (to avoid DNS issues).
3. Use clients only in transient way only (for operations that take not longer than few minutes). 
   1. IHttpClientFactory.CreateClient() to create HttpClient and use it only in with transient lifecycle. HttpClient contains hard link to HttpMessageHandler. You may dispose HttpClient created by IHttpClientFactory but that will not dispose referenced HttpMessageHandler. [Typed HttpClient](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0#typed-clients) is also for transient only approach. DefaultHttpClientFactory caches HttpMessageHandler after IHttpClientFactory.CreateClient() infocation for 2 minutes. Transient ussage of HttpClient will guarantee that cached but fresh handlers will be used.
   2. Use IHttpMessageHandlerFactory.CreateHandler() to create HttpMessageHandler that may be used for transient connection wrappers (e.g. [DocumentClient](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.documents.client.documentclient.-ctor?view=azure-dotnet), [KeyVaultClient](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.keyvault.keyvaultclient.-ctor?view=azure-dotnet-legacy)).
4. If you realy need to out of SNAT ports limit on AppService then consider few options. 
   1. Use [App Service Environments](https://docs.microsoft.com/en-us/azure/app-service/environment/intro)
   2. Use [NAT Gateways](https://docs.microsoft.com/en-us/azure/virtual-network/nat-gateway-resource), service endpoints, private endpoints to avoid SNAT restrictions.
   3. Use other protocol connection pools (e.g. SQL connection pools).

Here is the list of articles and key concepts that it is possible to mine from them:
- [DI scopes in IHttpClientFactory message handlers don't work like you think they do](https://andrewlock.net/understanding-scopes-with-ihttpclientfactory-message-handlers/)This one is good deep article that proves results of our debugging.
- [Use IHttpClientFactory to implement resilient HTTP requests](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)
  Provides general practice is to use IHttpClientFactory with dependency injection.
- [Make HTTP requests using IHttpClientFactory in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0) 
  Provides 
- [Troubleshooting intermittent outbound connection errors in Azure App Service](https://docs.microsoft.com/en-us/azure/app-service/troubleshoot-intermittent-outbound-connection-errors)
  Contains symptoms, cause and general recomendations to avoid problems.
- [Manage connections in Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/manage-connections) provides wrong recommendation to use singleton for HttpClient and CosmosClient because it may cause [DNS issue](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0#named-clients). Azure Functions support [Dependency Injection](https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection) and [IHttpClientFactory](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0) can be injected.
- [Improper Instantiation antipattern](https://docs.microsoft.com/en-us/azure/architecture/antipatterns/improper-instantiation/) another MSDN article that recomends to use singleton that fixes SNAT ports issue bug creates DNS issue.